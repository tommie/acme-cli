#!/bin/bash
#
# An ACME challenge solver for "acmeclient issuecert" using an Apache
# server.
#
# This tries to do a minimum amount of work and leaving the validation
# to Apache. It can solve http-01 (cost 1) and tls-sni-01 (cost 2).
#
# See the "issuecert" section of README.md for more information.
#
# NOTE: At most one instance of this script may run at any one time.
# We assume $challenge_dir and $config_file are untouched by others.
#

# Avoid silent failures.
set -e
set -o pipefail

# A directory where http://$name/.well-known/acme-challenge is pointing
# for each $name you want to solve http-01. Note it's not using HTTPS,
# as mandated by the ACME specification, Sec. 7.2.
challenge_dir=${ACME_CHALLENGE_DIR:-/var/www/localhost/htdocs/.well-known/acme-challenge}

# A configuration file included by Apache. This is normally empty, but
# is populated to solve tls-sni-01.
config_file=${ACME_CONFIG_FILE:-/etc/apache2/acmeclient.conf}

# Program to execute with argument "reload" to reload Apache configuration.
apache2ctl=${ACME_APACHE2CTL:-apache2ctl}

# An empty directory used as document root for tls-sni-01 challenges.
empty_dir=/var/empty

progname=$(basename "$0")

if type -p gawk >/dev/null; then
    awk() {
	gawk "$@"
    }
elif type -p mawk >/dev/null; then
  # mawk batches line reading unless -Winteractive is given.
    awk() {
	mawk -Winteractive "$@"
    }
fi

case "$ACME_MODE" in
cost)
  # Read challenge records up until the first empty line.
  # Writes cost on success, and nothing if we cannot solve all challenges.
  awk -F$'\t' '
      $1 == "http-01" { cost += 1; next; }
      $1 == "tls-sni-01" { cost += 2; next; }
      !$0 { exit 0; }
      { cost = -1; exit 0; }
      END { if (cost >= 0) print cost; }'
  ;;

solve)
  tmpdir=$(mktemp -d --tmpdir "$progname.XXXXXXXXXX")
  trap 'rm -fr "$tmpdir" "$challenge_dir"/*' EXIT

  # Read challenge records up until the first empty line.
  IFS=$'\n'
  cs=( $(awk -F$'\t' '!$0 { exit(0); } { print; }') )

  # Parse tab-separated CSV.
  IFS=$'\t'
  for c in "${cs[@]}"; do
    # Split CSV fields.
    read type fields <<<"$c"
    f=( $fields )

    case "$type" in
    http-01)
      # Save the key authorization to the publicly accessible file.
      echo "${f[1]}" >"$challenge_dir/${f[0]}"
      # Respond with the key authorization.
      echo "$type	${f[1]}"
      ;;
      
    tls-sni-01)
      # Create a key if we don't have one already.
      if [ -z "$key" ]; then
        key="$tmpdir/tmp.key"
	# This key is not really used for security. We just need something.
	# genrsa is annoyingly verbose.
        openssl genrsa -out "$key" 1024 2>/dev/null
      fi

      # Create the virtual hosts and their certificates.
      (
	echo "# This file was automatically generated by $progname on $(date +'%x %X')."
        for name in "${f[@]:2}"; do
	  # X.509 subject names have a limit of 64 bytes (see RFC 3280),
	  # which ACME always goes above. Use subjectAltName instead.
	  opensslconf="$tmpdir/openssl.cnf"
	  cat <<EOF >"$opensslconf"
[ req ]
distinguished_name = req_distinguished_name
x509_extensions = req_exts

[ req_distinguished_name ]
[ req_exts ]
subjectAltName = DNS:${name}
EOF
	  openssl req \
	      -x509 -new -batch -nodes \
	      -config "$opensslconf" \
	      -days 1 -subj "/" \
	      -key "$key" \
	      -outform PEM -out "$tmpdir/$name.cert"
          cat <<EOF
<VirtualHost *:443>
   ServerName $name
   DocumentRoot $empty_dir
   Options None
   Order allow,deny
   Allow from all
   SSLEngine on
   SSLCertificateKeyFile $key
   SSLCertificateFile $tmpdir/$name.cert
</VirtualHost>
EOF
        done
      ) >"$config_file"
      
      # Respond with the key authorization.
      echo "$type	${f[1]}"
      ;;
      
    *)
      echo "$progname: unhandled challenge type: $type" >&2
      exit 2
    esac
  done

  # If we have tls-sni-01 challenges, we need to reload Apache.
  if [ -n "$key" ]; then
    "$apache2ctl" reload
  fi
  
  # Wait for stdin EOF.
  cat >/dev/null

  # Clean up.
  if [ -n "$key" ]; then
    echo -n >"$config_file"
    "$apache2ctl" reload
  fi
  ;;

*)
  echo "$progname: unknown ACME mode: $ACME_MODE" >&2
  echo "$progname: this program should be run via acmeclient, not manually." >&2
  exit 1
esac
